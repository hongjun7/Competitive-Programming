// usage:
// MaxFlowDinic::init(n);
// MaxFlowDinic::add_edge(0, 1, 100, 100); // for bidirectional edge
// MaxFlowDinic::add_edge(1, 2, 100); // directional edge
// result = MaxFlowDinic::solve(0, 2); // source -> sink
// G[i][edgeIndex].res -> residual
//
// in order to find out the minimum cut, use `l'.
// if l[i] == 0, i is unrechable.
//
// O(V*V*E)
// with unit capacities, O(min(V^(2/3), E^(1/2)) * E)
struct MaxFlowDinic {
	typedef int flow_t;
	struct Edge {
		int next;
		size_t inv; /* inverse edge index */
		flow_t res; /* residual */
	};
	int n;
	vector<vector<Edge>> G;
	vector<int> q, l, start;

	void init(int _n) {
		n = _n;
		G.resize(n);
		for (int i = 0; i < n; i++) G[i].clear();
	}
	void add_edge(int s, int e, flow_t cap, flow_t caprev = 0) {
		Edge forward{ e, G[e].size(), cap };
		Edge reverse{ s, G[s].size(), caprev };
		G[s].push_back(forward);
		G[e].push_back(reverse);
	}
	bool assign_level(int source, int sink) {
		int t = 0;
		memset(&l[0], 0, sizeof(l[0]) * l.size());
		l[source] = 1;
		q[t++] = source;
		for (int h = 0; h < t && !l[sink]; h++) {
			int cur = q[h];
			for (const auto& e : G[cur]) {
				if (l[e.next] || e.res == 0) continue;
				l[e.next] = l[cur] + 1;
				q[t++] = e.next;
			}
		}
		return l[sink] != 0;
	}
	flow_t block_flow(int cur, int sink, flow_t current) {
		if (cur == sink) return current;
		for (int& i = start[cur]; i < G[cur].size(); i++) {
			auto& e = G[cur][i];
			if (e.res == 0 || l[e.next] != l[cur] + 1) continue;
			if (flow_t res = block_flow(e.next, sink, min(e.res, current))) {
				e.res -= res;
				G[e.next][e.inv].res += res;
				return res;
			}
		}
		return 0;
	}
	flow_t solve(int source, int sink) {
		q.resize(n);
		l.resize(n);
		start.resize(n);
		flow_t ans = 0;
		while (assign_level(source, sink)) {
			memset(&start[0], 0, sizeof(start[0]) * n);
			while (flow_t flow = block_flow(source, sink, numeric_limits<flow_t>::max()))
				ans += flow;
		}
		return ans;
	}
};